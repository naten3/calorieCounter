import {Map, List, fromJS} from 'immutable';
import {IAction} from "../models/actions";

// TODO: Find a way to build a hierarchical structure for reducers
export class ManagedReducer {
  private _createdReducer = null;
  private _actionHandlers:Map<string, Function> = Map<string, Function>();
  private _initialState:any;

  public identifier:string;

  constructor(identifier: string, initialState:any, actionHandlers?: Object[]) {
    if (identifier === undefined) throw new Error('Missing a required identifier for the reducer.');
    this.identifier = identifier;
    if (initialState === undefined) throw new Error('Missing a required initialState for the reducer.');
    this._initialState = fromJS(initialState);
    if (actionHandlers) this.addActionHandlers(actionHandlers);
  }

  addActionHandler(identifier: string, handler:Function):ManagedReducer {
    this._actionHandlers = this._actionHandlers.set(
      identifier,
      handler
    );
    return this;
  }

  addActionHandlers(actions:Object):ManagedReducer {
    Object.keys(actions).map(key => this.addActionHandler(key, actions[key]));
    return this;
  }

  setInitialState(initialState:any):ManagedReducer {
    this._initialState = fromJS(initialState);
    return this;
  }

  create():Function {
    if (this._createdReducer !== null) return this._createdReducer;
    const lockedActions = this._actionHandlers.toMap();
    return this._createdReducer = (state:any = this._initialState, action:IAction = null) => {
      state = fromJS(state);
      if (action === null) return state; // TODO: Throw error or die silently?
      if (!lockedActions.has(action.type)) return state;
      let actionHandler = lockedActions.get(action.type);
      return actionHandler(state, action);
    }
  }
}