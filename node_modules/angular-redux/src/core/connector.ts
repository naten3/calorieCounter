import {Map, fromJS} from 'immutable';
import {Store, Dispatch} from 'redux';
import _ = require('lodash');
import wrapActionCreators from '../utils/wrapActionCreators';
import shallowEqual from '../utils/shallowEqual';
import {ManagedStore} from './managedStore';

/** @module core/Connector */

/**
 * The Connector-class provides the application with shared store connector functionality.
 * @class
 * */
export class Connector {
  public static instance = null;

  private _defaultMapStateToTarget = (state => {
    return state;
  });
  private _defaultMapDispatchToTarget = dispatch => dispatch;
  private _store:Store;

  constructor() {
    this._store = ManagedStore.instance.getStore();
  }

  /**
   * Runs the new state through the scope mapping functions and validates that the result implements
   * required immutable methods.
   * @param state The current state.
   * @param mapStateToScope The scope mapping function.
   * @returns {Map<any, any>} The mapped state.
   */
  mapAndValidateState(state:any, mapStateToScope:Function):any {
    const newState = mapStateToScope(state);
    if (!newState) {
      return state;
    }
    return newState;
  }

  /**
   * Applies the updated state to the target Object.
   * @param target The target Object.
   * @param state Current state.
   * @param dispatch Store dispatch Object.
   */
  updateTarget(target:any, state:any, dispatch:Dispatch) {
    state = state.toJS();
    if (_.isFunction(target)) {
      target(state, dispatch);
    } else {
      Object.assign(target, state, dispatch);
    }
  }

  /**
   * Prepares a connect function that allows mapping of the given stores state to a target Object.
   * @param mapStateToTarget Function for mapping the state to the target scope.
   * @param mapDispatchToTarget Function for mapping the actions to the dispatcher.
   * @returns {function((Function|Object)): Function} Prepared connect function that can apply the connection to
   * the target Object.
   */
  map(mapStateToTarget?:Function, mapDispatchToTarget?:Function) {
    const finalMapStateToTarget:Function = mapStateToTarget || this._defaultMapStateToTarget;
    const finalMapDispatchToTarget:Function = _.isPlainObject(mapDispatchToTarget)
      ? wrapActionCreators(mapDispatchToTarget)
      : mapDispatchToTarget || this._defaultMapDispatchToTarget;

    let targetState = this.mapAndValidateState(fromJS(this._store.getState()), finalMapStateToTarget);
    const actions = finalMapDispatchToTarget(this._store.dispatch);

    return {
      connect: (target:Function|Object) => {
        this.updateTarget(target, targetState, actions);

        return this._store.subscribe(() => {
          const nextState = this.mapAndValidateState(fromJS(this._store.getState()), finalMapStateToTarget);
          if (!shallowEqual(targetState, nextState)) {
            targetState = nextState;
            this.updateTarget(target, targetState, actions);
          }
        });
      },
      store: this._store
    }
  }
}

export default Connector;