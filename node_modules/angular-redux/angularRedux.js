(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("immutable"), require("redux"), require("angular2/core"), require("lodash"), require("redux-thunk"));
	else if(typeof define === 'function' && define.amd)
		define(["immutable", "redux", "angular2/core", "lodash", "redux-thunk"], factory);
	else if(typeof exports === 'object')
		exports["angularRedux"] = factory(require("immutable"), require("redux"), require("angular2/core"), require("lodash"), require("redux-thunk"));
	else
		root["angularRedux"] = factory(root["immutable"], root["redux"], root["angular2/core"], root["lodash"], root["redux-thunk"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	// Models
	__export(__webpack_require__(8));
	__export(__webpack_require__(9));
	// Core
	__export(__webpack_require__(1));
	__export(__webpack_require__(5));
	__export(__webpack_require__(3));
	__export(__webpack_require__(6));
	// Decorators
	__export(__webpack_require__(7));
	//# sourceMappingURL=index.js.map

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var immutable_1 = __webpack_require__(2);
	var _ = __webpack_require__(13);
	var wrapActionCreators_1 = __webpack_require__(11);
	var shallowEqual_1 = __webpack_require__(10);
	var managedStore_1 = __webpack_require__(3);
	/** @module core/Connector */
	/**
	 * The Connector-class provides the application with shared store connector functionality.
	 * @class
	 * */
	var Connector = (function () {
	    function Connector() {
	        this._defaultMapStateToTarget = (function (state) {
	            return state;
	        });
	        this._defaultMapDispatchToTarget = function (dispatch) { return dispatch; };
	        this._store = managedStore_1.ManagedStore.instance.getStore();
	    }
	    /**
	     * Runs the new state through the scope mapping functions and validates that the result implements
	     * required immutable methods.
	     * @param state The current state.
	     * @param mapStateToScope The scope mapping function.
	     * @returns {Map<any, any>} The mapped state.
	     */
	    Connector.prototype.mapAndValidateState = function (state, mapStateToScope) {
	        var newState = mapStateToScope(state);
	        if (!newState) {
	            return state;
	        }
	        return newState;
	    };
	    /**
	     * Applies the updated state to the target Object.
	     * @param target The target Object.
	     * @param state Current state.
	     * @param dispatch Store dispatch Object.
	     */
	    Connector.prototype.updateTarget = function (target, state, dispatch) {
	        state = state.toJS();
	        if (_.isFunction(target)) {
	            target(state, dispatch);
	        }
	        else {
	            Object.assign(target, state, dispatch);
	        }
	    };
	    /**
	     * Prepares a connect function that allows mapping of the given stores state to a target Object.
	     * @param mapStateToTarget Function for mapping the state to the target scope.
	     * @param mapDispatchToTarget Function for mapping the actions to the dispatcher.
	     * @returns {function((Function|Object)): Function} Prepared connect function that can apply the connection to
	     * the target Object.
	     */
	    Connector.prototype.map = function (mapStateToTarget, mapDispatchToTarget) {
	        var _this = this;
	        var finalMapStateToTarget = mapStateToTarget || this._defaultMapStateToTarget;
	        var finalMapDispatchToTarget = _.isPlainObject(mapDispatchToTarget)
	            ? wrapActionCreators_1.default(mapDispatchToTarget)
	            : mapDispatchToTarget || this._defaultMapDispatchToTarget;
	        var targetState = this.mapAndValidateState(immutable_1.fromJS(this._store.getState()), finalMapStateToTarget);
	        var actions = finalMapDispatchToTarget(this._store.dispatch);
	        return {
	            connect: function (target) {
	                _this.updateTarget(target, targetState, actions);
	                return _this._store.subscribe(function () {
	                    var nextState = _this.mapAndValidateState(immutable_1.fromJS(_this._store.getState()), finalMapStateToTarget);
	                    if (!shallowEqual_1.default(targetState, nextState)) {
	                        targetState = nextState;
	                        _this.updateTarget(target, targetState, actions);
	                    }
	                });
	            },
	            store: this._store
	        };
	    };
	    Connector.instance = null;
	    return Connector;
	})();
	exports.Connector = Connector;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Connector;
	//# sourceMappingURL=connector.js.map

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var redux_1 = __webpack_require__(4);
	var immutable_1 = __webpack_require__(2);
	var thunk = __webpack_require__(14);
	/**
	 * Managed Store wrapper for a Redux store and it's actions and reducers.
	 */
	var ManagedStore = (function () {
	    function ManagedStore() {
	        this._storeInstance = null;
	        this._reducers = immutable_1.Map();
	        this.middleware = immutable_1.List().push(thunk);
	    }
	    Object.defineProperty(ManagedStore.prototype, "initialState", {
	        get: function () {
	            return this._initialState.toJS();
	        },
	        set: function (value) {
	            this._initialState = immutable_1.fromJS(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ManagedStore.prototype.addReducer = function (managedReducer) {
	        this._reducers = this._reducers.set(managedReducer.identifier, managedReducer);
	        return this;
	    };
	    ManagedStore.prototype.addReducers = function (managedReducers) {
	        managedReducers.map(this.addReducer.bind(this));
	        return this;
	    };
	    ManagedStore.prototype.getStore = function () {
	        if (this._storeInstance === null) {
	            if (!this._initialState)
	                throw new Error('Missing required initial state.');
	            if (this._reducers.size === 0)
	                throw new Error('No reducers defined. Need atleast one reducer for the store.');
	            var creator = redux_1.applyMiddleware.apply(void 0, [thunk].concat(this.middleware.toArray()))(redux_1.createStore);
	            var createdReducers = this._reducers.map(function (reducer) { return reducer.create(); });
	            var rootReducer = redux_1.combineReducers(createdReducers.toJS());
	            this._storeInstance = creator(rootReducer, this._initialState.toJS());
	        }
	        return this._storeInstance;
	    };
	    ManagedStore.initialize = function (callback) {
	        if (ManagedStore.instance !== null)
	            throw new Error('Unable to reinitialize a read-only singleton.');
	        if (!callback)
	            throw new Error('Missing the required callback for instance configuration.');
	        var instance = new ManagedStore();
	        callback(instance);
	        ManagedStore.instance = instance;
	        return instance.getStore();
	    };
	    ManagedStore.destroy = function () {
	        delete ManagedStore['instance'];
	        ManagedStore['instance'] = null;
	    };
	    ManagedStore.instance = null;
	    return ManagedStore;
	})();
	exports.ManagedStore = ManagedStore;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ManagedStore;
	//# sourceMappingURL=managedStore.js.map

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var immutable_1 = __webpack_require__(2);
	// TODO: Find a way to build a hierarchical structure for reducers
	var ManagedReducer = (function () {
	    function ManagedReducer(identifier, initialState, actionHandlers) {
	        this._createdReducer = null;
	        this._actionHandlers = immutable_1.Map();
	        if (identifier === undefined)
	            throw new Error('Missing a required identifier for the reducer.');
	        this.identifier = identifier;
	        if (initialState === undefined)
	            throw new Error('Missing a required initialState for the reducer.');
	        this._initialState = immutable_1.fromJS(initialState);
	        if (actionHandlers)
	            this.addActionHandlers(actionHandlers);
	    }
	    ManagedReducer.prototype.addActionHandler = function (identifier, handler) {
	        this._actionHandlers = this._actionHandlers.set(identifier, handler);
	        return this;
	    };
	    ManagedReducer.prototype.addActionHandlers = function (actions) {
	        var _this = this;
	        Object.keys(actions).map(function (key) { return _this.addActionHandler(key, actions[key]); });
	        return this;
	    };
	    ManagedReducer.prototype.setInitialState = function (initialState) {
	        this._initialState = immutable_1.fromJS(initialState);
	        return this;
	    };
	    ManagedReducer.prototype.create = function () {
	        var _this = this;
	        if (this._createdReducer !== null)
	            return this._createdReducer;
	        var lockedActions = this._actionHandlers.toMap();
	        return this._createdReducer = function (state, action) {
	            if (state === void 0) { state = _this._initialState; }
	            if (action === void 0) { action = null; }
	            state = immutable_1.fromJS(state);
	            if (action === null)
	                return state; // TODO: Throw error or die silently?
	            if (!lockedActions.has(action.type))
	                return state;
	            var actionHandler = lockedActions.get(action.type);
	            return actionHandler(state, action);
	        };
	    };
	    return ManagedReducer;
	})();
	exports.ManagedReducer = ManagedReducer;
	//# sourceMappingURL=managedReducer.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var core_1 = __webpack_require__(12);
	var connector_1 = __webpack_require__(1);
	var connector = null;
	/**
	 * Provides all related redux providers to the DI system.
	 * @returns {Provider}
	 */
	exports.REDUX_PROVIDERS = [
	    core_1.provide(connector_1.default, { useFactory: function () { return new connector_1.default(); } })
	];
	//# sourceMappingURL=provider.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var connector_1 = __webpack_require__(1);
	/**
	 * A decorator that binds the decorated component with the specified redux store instance.
	 * @param mapStateToTarget Function to map the store state for the component.
	 * @param mapDispatchToTarget Function to map dispatcher actions to the store.
	 */
	function ConnectToStore(mapStateToTarget, mapDispatchToTarget) {
	    return function (target) {
	        var originalInit, unsubscribe, originalDestroy;
	        // Bind initialization to lifecycle handler
	        if (target.prototype.ngOnInit)
	            originalInit = target.prototype.ngOnInit;
	        target.prototype.ngOnInit = function () {
	            var finalMapStateToTarget = mapStateToTarget
	                ? mapStateToTarget.bind(this)
	                : this['mapStateToTarget'].bind(this);
	            var finalMapDispatchToTarget = mapDispatchToTarget
	                ? mapDispatchToTarget.bind(this)
	                : this['mapDispatchToTarget'].bind(this);
	            var connector = new connector_1.default().map(finalMapStateToTarget, finalMapDispatchToTarget);
	            unsubscribe = connector.connect(this);
	            this.store = connector.store;
	            if (originalInit)
	                originalInit.apply(void 0, arguments);
	        };
	        // Bind unsubscription to lifecycle handler
	        if (target.prototype.ngOnDestroy)
	            originalDestroy = target.prototype.ngOnDestroy;
	        target.prototype.ngOnDestroy = function () {
	            unsubscribe();
	            if (originalDestroy)
	                originalDestroy.apply(void 0, arguments);
	        };
	    };
	}
	exports.ConnectToStore = ConnectToStore;
	//# sourceMappingURL=connectToStore.js.map

/***/ },
/* 8 */
/***/ function(module, exports) {

	//# sourceMappingURL=actions.js.map

/***/ },
/* 9 */
/***/ function(module, exports) {

	var ManagedReducerActionArgs = (function () {
	    function ManagedReducerActionArgs(creator, handler) {
	        this.creator = creator;
	        this.handler = handler;
	    }
	    ;
	    return ManagedReducerActionArgs;
	})();
	exports.ManagedReducerActionArgs = ManagedReducerActionArgs;
	//# sourceMappingURL=managedReducer.js.map

/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * Do a shallow comparison of two objects
	 * @param a The first object to compare.
	 * @param b The second object to compare.
	 * @returns {boolean} True for equal result.
	 */
	function shallowEqual(a, b) {
	    if (a === b)
	        return true;
	    var keysA = Object.keys(a);
	    var keysB = Object.keys(b);
	    if (keysA.length !== keysB.length)
	        return false;
	    for (var i = 0; i < keysA.length; i++) {
	        if (!b.hasOwnProperty(keysA[i]) || a[keysA[i]] !== b[keysA[i]]) {
	            return false;
	        }
	    }
	    return true;
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = shallowEqual;
	//# sourceMappingURL=shallowEqual.js.map

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var redux_1 = __webpack_require__(4);
	/**
	 * Wrap a bundle of actionCreators into a bindActionCreators function.
	 * See {@link http://rackt.org/redux/docs/api/bindActionCreators.html} for more information.
	 * @param actionCreators ActionCreator definitions as a bundled object.
	 * @returns {function(any=): *} Bound action creator functions using bindActionCreators.
	 */
	function wrapActionCreators(actionCreators) {
	    return function (dispatch) { return redux_1.bindActionCreators(actionCreators, dispatch); };
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = wrapActionCreators;
	//# sourceMappingURL=wrapActionCreators.js.map

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_14__;

/***/ }
/******/ ])
});
;